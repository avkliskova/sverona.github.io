<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Blogs on S. Verona Malone</title><link>https://sverona.dev/blog/</link><description>Recent content in Blogs on S. Verona Malone</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sun, 03 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://sverona.dev/blog/index.xml" rel="self" type="application/rss+xml"/><item><title>Mimicking LaTeX theorem environments with CSS</title><link>https://sverona.dev/blog/mimicking-latex-theorem-environments-with-css/</link><pubDate>Sun, 08 Aug 2021 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/mimicking-latex-theorem-environments-with-css/</guid><description>LaTeX supports &amp;ldquo;theorem environments,&amp;rdquo; like this:
(Image)
These aren&amp;rsquo;t hard to mimic with :before and :after:
article { counter-reset: definition theorem lemma example proposition corollary; } .definition:before { counter-increment: definition; content: &amp;#34;Definition &amp;#34; counter(definition) &amp;#34;.&amp;#34;; font-weight: bold; } .theorem:before { counter-increment: theorem; content: &amp;#34;Theorem &amp;#34; counter(theorem) &amp;#34;.&amp;#34;; font-weight: bold; } .lemma:before { counter-increment: lemma; content: &amp;#34;Lemma &amp;#34; counter(lemma) &amp;#34;.&amp;#34;; font-weight: bold; } .example:before { counter-increment: example; content: &amp;#34;Example &amp;#34; counter(example) &amp;#34;.</description></item><item><title>\(\pi\) and \(e\) and the GCD</title><link>https://sverona.dev/blog/gcd-ln/</link><pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/gcd-ln/</guid><description>While doing some research for my Project Euler post, I found myself drawn to something else that blew my mind in high school &amp;mdash; the connection between the greatest common divisor and the Riemann zeta function.
For those of you just joining us:
The greatest common divisor of two nonzero integers is the largest positive number that divides them both. The Riemann zeta function is the series \[\zeta(s) = \sum_{n = 1}^\infty \frac1{n^s} = \frac1{1^s} + \frac1{2^s} + \frac1{3^s} + \cdots.</description></item><item><title>Project Euler 1-100 in 49 hours</title><link>https://sverona.dev/blog/project-euler/</link><pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/project-euler/</guid><description>Project Euler is how I taught myself Python in high school, and so I find it incredibly nostalgic. It took 13-year-old me a lot of Googling and a few months to get through the first 100 problems.
10-odd years and a graduate degree later, I decided to come back and solve them as fast as I could. I&amp;rsquo;m no competitive programmer, but 24 hours seemed reasonable. Fortunately, I lack the stamina to code for that long, so I did it over a few days instead.</description></item><item><title>Neural networks in time scale calculus</title><link>https://sverona.dev/blog/nabla/</link><pubDate>Tue, 07 May 2019 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/nabla/</guid><description>Neural networks are a popular technique for machine learning problems such as automated handwriting recognition, automated speech recognition, and time-series forecasting. On these tasks, so-called deep neural networks [Schmidhuber 2015] and convolutional neural networks [Ciresan et al.Â 2011] have performed at least as well as the best known non-neural-network statistical learning techniques. A typical neural network numerically solves an extremization problem using gradient descent in a high-dimensional Euclidean space using an algorithm known as backpropagation.</description></item><item><title>The dual simplex method, an introduction</title><link>https://sverona.dev/blog/dual-simplex/</link><pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/dual-simplex/</guid><description>The primal simplex method provides an algorithmic means for solving linear programs (hereinafter LPs.) This document motivates, defines, and applies the so-called dual simplex method, a slight variant which is useful for performing post hoc sensitivity analysis on LPs solved by the simplex method.
The primal simplex method In this section, we review the three steps of the usual primal method, following [Hillier-Lieberman], Frederick S. Hillier and Gerald J. Lieberman, Introduction to operations research, 10th ed.</description></item></channel></rss>