---
title: Computational methods
description: An overview of the `dc-lattices` library.
sequence: thesis
date: 2020-11-01
completion_status: complete
epistemic_status: confident
weight: 8
math: true
---

This chapter outlines the Python code provided in Appendix A.

## Overview of the `dc-lattices` library

In this section we describe the contents of each file listed in Appendix
A.

1. `dc_lattice.py` contains the abstract initialization and population routines for generic DCDLs.  We model a DCDL as a graph using the `networkx` library.
2. `incremental_lattice.py` overrides some methods in `dc_lattice.py` to handle generic /incremental/ lattices (which, it should be noted, includes every example in this thesis.)
3. `boolean_lattice.py`, `zps_lattice.py`, and `fibonacci_lattice.py` implement the lattices described in Chapter 3.
4. `catalan_lattice.py` implements the lattices described in Chapter 4.
5. `gt_pattern.py` contains routines to generate all Gelfand-Tsetlin patterns of a prescribed size using a standard backtracking search.{{% sidenote %}} *Nota bene:* The constructor for `CatalanLattice` assumes the second argument is \\(2k\\), not \\(k\\). Calling, for instance, `CatalanLattice(3, 1)` will not work. {{% /sidenote %}}
6. `lr_tableaux.py` contains routines to generate all Littlewood-Richardson tab-leaux of the shape described in Chapter 5, again using backtracking search.
7. `eppstein_layout.py` is described in the next section.

## Drawing incremental lattices

Most of the figures in this document were generated by the `networkx`
and `matplotlib` libraries, using in particular the force-directed graph
drawing algorithm (see [@kamada-kawai].) Implementation details appear
in the file `dc_lattice.py` under the method `draw()`.

### Eppstein's graph drawing algorithm

We also implement an algorithm due to [@eppstein] that is tailored
specifically to incremental lattices, which Eppstein calls *media*.
Implementation details appear in the file `eppstein_layout.py`.

The idea is to linearly project a graph \\(G\\) onto \\(\mathbb Z^2\\); that is,
to produce vectors \\(\mathbf x, \mathbf y \in \mathbb Z^n\\) so that, given
an embedding \\(\mathbf \phi : G \to \mathbb Z^n\\) of \\(G\\), the vertex
\\(v \in G\\) is positioned at
\\(\mathbf x \cdot \phi(v), \mathbf y \cdot \phi(v)\\).

We would like to choose \\(\mathbf x\\) and \\(\mathbf y\\) so as to satisfy the
following properties:

1. The entries of \\(\mathbf x\\) and \\(\mathbf y\\) should be distinct, so that the product structure of the graph is made apparent in the projection; that is, graph edges which correspond to increments in the same coordinate should be represented by the same vector.
2. Collinear edges should not overlap.
3. No edge should come within a fixed distance \\(d\\) of any vertex to which it is not incident.

Eppstein accomplishes this as follows. Fix an embedding
\\(\phi : G \to \mathbb Z^n\\) and let its components be denoted by
\\(\phi\_1, \dots, \phi\_n\\). Note that the pullback \\(\phi\_k^{-1}[j]\\) is
simply the \\(k\\)-slice through \\(j\\). Now define

\\[\begin{aligned}
x\_k &= \begin{cases} 0,  & k = 1 \newline \max\limits\_{\substack{\phi\_k^{-1}[j] \not = \varnothing \newline \phi\_k^{-1}[j - 1] \not = \varnothing}} \left(\min\limits\_{v \in \phi\_k^{-1}[j]} \sum\limits\_{i=1}^{k-1}  x\_i \phi\_i(v) - \max\limits\_{v \in \phi\_k^{-1}[j-1]} \sum\limits\_{i=1}^{k-1} x\_i \phi\_i(v)\right) + d, & 1 < k \leq n;\end{cases} \newline
y\_k &= \begin{cases} 0,  & k = n \newline \max\limits\_{\substack{\phi\_k^{-1}[j] \not = \varnothing \newline \phi\_k^{-1}[j - 1] \not = \varnothing}} \left(\min\limits\_{v \in \phi\_k^{-1}[j]} \sum\limits\_{i=k+1}^{n} y\_i \phi\_i(v) - \max\limits\_{v \in \phi\_k^{-1}[j-1]} \sum\limits\_{i=k+1}^{n} y\_i \phi\_i(v)\right) + d, & 1 \leq k < n.\end{cases}
\end{aligned}\\]

These values generally must be computed recursively. Intuitively, the
quantity inside the parentheses is the amount by which the consecutive
\\(k\\)-slices \\(\phi\_k^{-1}[j-1]\\), \\(\phi\_k^{-1}[j]\\) would overlap if \\(G\\)
were projected with all of \\(x\_k, x\_{k + 1}, \dots, x\_n\\) (or
\\(y\_k, y\_{k-1}, \dots, y\_1\\)) set to zero. Thus, setting \\(X\_k\\) (or \\(Y\_k\\))
to that value plus \\(d\\) guarantees \\(d\\) units of separation.

## Certifying product solitarity

By *certifying the product solitarity* of a given DCDL \\(L\\), we mean to
answer the following question. Suppose a set of positive rational edge
products exist for \\(L\\). What is the largest subset of \\(L\\) with
verifiably unique edge products?{{% sidenote %}} Note that we need not actually *calculate* these edge products.{{% /sidenote %}}

The algorithm we use, which is implemented in `dc_lattice.py` under the
routines `solvable_from()` and `solvable_subgraph()`, is fairly crude.
It relies on three facts which we have already shown:

1. The set of edge products for a chain are uniquely determined.
2. Once the edge products for one face of a monochromatic component are uniquely determined, the edge products for the entire component are.
3. Once the edge products on three edges of a diamond are determined, so is the fourth.

It proceeds as follows.

1. Initialize a queue \\(Q\\) of known-solvable edges, and a list \\(S\\) of ``visited" solved edges.
2. Push any edges known *a priori* onto \\(Q\\).
3. Determine all chains. Push their edges onto \\(Q\\).
4. If \\(Q\\) is empty, halt and return \\(S\\).
5. Pop an edge \\(e\\) from \\(Q\\). Add it to \\(S\\).
6. Check if the component \\(e\\) belongs to has a solvable face. If so, push all of that component's edges onto \\(Q\\).
7. Check for any diamonds having three edges in \\(S\\). If any are found, add those diamonds' fourth edges to \\(Q\\).
8. Set \\(Q = Q \setminus S\\).
9. Go to 4.

The foregoing facts assure that at any stage during the execution of
this algorithm, the set \\(S\\) consists only of edges with uniquely
determined products. It should also be clear that this algorithm halts,
since step 8 ensures that any edge is handled at most once.

Note that this algorithm *does not* find a *maximal* subset on which
edge products are uniquely determined. For instance, while
\\(\mathscr F(3, 3)\\) is product solitary, this fact depends on the zero
discriminant of a quadratic equation arising from a diamond relation,
which is not one of the criteria used by the algorithm. So calling
`solvable_from` on \\(\mathscr F(3, 3)\\) without any known edges fails.
However, if the edge product \\(\pi\_{147,157}\\) is assumed known, the
routine succeeds.

Some further improvements to this code should be fairly straightforward.
For instance, the framework provided should make it simple to actually
calculate the edge products. Doing so may provide empirical insight into
the question asked at the end of Chapter 4. It should also be easy to
produce interactive visualizations of the lattices generated, perhaps
using an appropriate JavaScript library.

