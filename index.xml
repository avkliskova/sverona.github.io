<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>S. Verona Malone</title><link>https://sverona.dev/</link><description>Recent content on S. Verona Malone</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 05 Oct 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://sverona.dev/index.xml" rel="self" type="application/rss+xml"/><item><title>Abstract</title><link>https://sverona.dev/blog/thesis/abstract/</link><pubDate>Sun, 01 Nov 2020 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/thesis/abstract/</guid><description/></item><item><title>Elementary Mathematics</title><link>https://sverona.dev/blog/feynman/elementary-mathematics/</link><pubDate>Mon, 01 Jan 1945 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/feynman/elementary-mathematics/</guid><description>Table of Contents Equations
Example: Interpolation Example: Iteration Example: Newton's method Problems
Power Series
Summation by Integration and Differentiation Convergence: Ratio Test Equations The simplest way to solve any equation - except linear or quadratic equations - is by trial and error.
Example: Interpolation \(\frac{1}{1 + x^2} = 2x\)
\[\begin{array}{|l|l|l|l|} \mathbf{x} &amp;amp; \textbf{LHS} &amp;amp; \textbf{RHS} &amp;amp; \textbf{Difference} \newline 0 &amp;amp; 1 &amp;amp; 0 &amp;amp; 1 \newline 1 &amp;amp; .</description></item><item><title>Introduction</title><link>https://sverona.dev/blog/thesis/introduction/</link><pubDate>Sun, 01 Nov 2020 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/thesis/introduction/</guid><description/></item><item><title>Series</title><link>https://sverona.dev/blog/feynman/series/</link><pubDate>Mon, 07 Oct 1946 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/feynman/series/</guid><description>Abel Summability Consider the series \(1 - 2 + 3 - \dots.\) Convert it to a power series in \(x\) as follows: \(S(x) = 1 - 2x + 3x^2 - \dots\)
Sum this power series:
\[\begin{aligned} \int S(x) ~dx &amp;amp;= x - x^2 + x^3 - \dots = \frac{x}{1 + x} \newline S(x) &amp;amp;= \frac{d}{dx}\left[\frac{x}{1 + x}\right] = \frac1{(1 + x)^2} \end{aligned}\]
The Abel sum of the original series is defined as the \(\lim_{x \to 1-} S(x)\).</description></item><item><title>Lattice theory</title><link>https://sverona.dev/blog/thesis/lattice-theory/</link><pubDate>Sun, 01 Nov 2020 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/thesis/lattice-theory/</guid><description>This section and the next introduce the mathematics necessary to read Chapter 3. The main results draw from combinatorial lattice theory and the representation theory of Lie algebras.
In this section we present a number of standard definitions and notions concerning posets and lattices, in particular the diamond-colored distributive lattices (DCDLs). DCDLs provide the setting for the graph-theoretic arguments and algorithms appearing in the sequel.
The primary references for this section are [Donnelly 2018] Robert G.</description></item><item><title>Integration</title><link>https://sverona.dev/blog/feynman/integration/</link><pubDate>Mon, 01 Jan 1945 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/feynman/integration/</guid><description>Methods Substitution By parts Differentiation of a parameter Series expansion Contour integration Numerical methods Special tricks Methods 3 to 7 are applicable particularly to definite integrals.
Complex Variable in Substitution Find \(\int_0^\infty e^{-ax} \cos bx ~\mathrm dx.\)
Since \(\cos bx = (e^{ibx} + e^{-ibx})/2\), we have
\[\begin{aligned} \int_0^\infty e^{-ax} \cos bx &amp;amp;= \frac12 \int_0^\infty e^{-(a - ib)x} ~\mathrm dx + \frac12 \int_0^\infty e^{-(a + ib)x} ~\mathrm dx \newline &amp;amp;= \frac12 \left( \frac1{a - ib} + \frac1{a + ib} \right) \newline &amp;amp;= \frac{a}{a^2 + b^2} \end{aligned}\]</description></item><item><title>Lie theory</title><link>https://sverona.dev/blog/thesis/lie-theory/</link><pubDate>Sun, 01 Nov 2020 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/thesis/lie-theory/</guid><description>A full exposition of the theory of Lie algebras and their representations is well beyond the scope of this paper. We provide here only the necessary definitions and theorems to read §3.
We loosely follow [Humphreys 1972] James E. Humphreys. Introduction to Lie algebras and representation theory. Springer-Verlag, 1972. An introduction to the subject more suitable for advanced undergraduates is [@erdmann-wildon].
A Lie algebra is a vector space \(\mathfrak g\) together with a bracket operation \([ \cdot, \cdot ] : \mathfrak g \times \mathfrak g \to \mathfrak g\) satisfying the following axioms for each \(x, y, z \in \mathfrak g\) and scalars \(a, b\):</description></item><item><title>Supporting graphs</title><link>https://sverona.dev/blog/thesis/supporting-graphs/</link><pubDate>Sun, 01 Nov 2020 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/thesis/supporting-graphs/</guid><description>We now present the centerpiece of the work. Throughout, write \([n] = \mathbb N \cap [1, n].\)
The DCS relations Let \(L\) be a diamond-colored distributive lattice with edges colored by \([n]\), and let \(x \in L\). For each \(i \in \mathbb N\), let \(\top_i(x) \in L\) be the maximum element of the \(i\)-component in which \(x\) lies.
Define a weight function The quantity \(\rho_i(\top_i(x)) - \rho_i(x))\) is the distance of \(x\) “from the top” of its \(i\)-component, whereas \(\rho_i(x)\) is the distance of \(x\) “from the bottom.</description></item><item><title>Catalanian lattices</title><link>https://sverona.dev/blog/thesis/catalanian-lattices/</link><pubDate>Sun, 01 Nov 2020 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/thesis/catalanian-lattices/</guid><description>This section introduces and proves the author's main results.
Gelfand-Tsetlin patterns A Gelfand-Tsetlin pattern or just GT pattern of order \(n\) is an \(n \times n\) lower triangular matrix with integer entries that satisfies \(g_{i + 1, j} \leq g_{ij} \leq g_{i +1, j + 1}\) for any \(1 \leq j \leq i \leq n.\) This definition is equivalent to that given in [@stanley-ec2] §7.10. We represent GT patterns as matrices here for ease of computation and typesetting.</description></item><item><title>Paths and tableaux</title><link>https://sverona.dev/blog/thesis/motzkin-paths/</link><pubDate>Sun, 01 Nov 2020 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/thesis/motzkin-paths/</guid><description>Motzkin paths A topside peakless Motzkin path of length \(n\) is a sequence \({p_i}_{i=1}^n\) such that for each \(1 \leq i \leq n,\)
\(p_i \in {-1, 0, 1};\) \(\sum_{k=1}^i p_k \geq 0;\) if \(p_{i - 1} = 1\), \(p_i \not = -1,\) and for which \(\sum_{i=1}^n p_i = 0.\) By calling \({p_i}_{i=1}^n\) a &amp;ldquo;path,&amp;rdquo; we mean to identify it with the series of points \({(i, \sum_{k=1}^i p_k)}_{i=1}^n\). The above definition then says</description></item><item><title>Computational methods</title><link>https://sverona.dev/blog/thesis/computational-methods/</link><pubDate>Sun, 01 Nov 2020 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/thesis/computational-methods/</guid><description>This chapter outlines the Python code provided in Appendix A.
Overview of the dc-lattices library In this section we describe the contents of each file listed in Appendix A.
dc_lattice.py contains the abstract initialization and population routines for generic DCDLs. We model a DCDL as a graph using the networkx library.
incremental_lattice.py overrides some methods in dc_lattice.py to handle generic /incremental/ lattices (which, it should be noted, includes every example in this thesis.</description></item><item><title>The tangent and secant curves</title><link>https://sverona.dev/trig/tangent-secant/</link><pubDate>Tue, 05 Oct 2021 00:00:00 +0000</pubDate><guid>https://sverona.dev/trig/tangent-secant/</guid><description>.small { font-size: smaller; } What we know already The graphs of sine or cosine make waves, like this:
[Desmos]
These graphs can have horizontal and vertical shifts, squishes, stretches, and/or flips.
Some of these have special names. We call horizontal shifts phase shifts. A horizontal squish or stretch is a change in the period. A vertical stretch or squish is a change in the amplitude.
Given a generic sine or cosine function \(f(x) = A \sin(Bx + C) + D\), we can determine the period as \(\dfrac{2\pi}{|B|},\) the phase shift as \(\dfrac{-C}{B}\), and the amplitude as \(|A|.</description></item><item><title>Annotated MERN III: Frontend</title><link>https://sverona.dev/blog/mern/frontend/</link><pubDate>Sun, 03 Oct 2021 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/mern/frontend/</guid><description>This post continues our look at James Vickery&amp;rsquo;s simple-mern repository. Today we&amp;rsquo;ll look at the React frontend, under the client/ folder.
package-lock.json We&amp;rsquo;ll ignore package-lock.json, since it was covered previously.
package.json package.json looks very similar to what create-react-app spits out. There are some new options, though, so let&amp;rsquo;s look at them.
{ &amp;#34;proxy&amp;#34;: &amp;#34;http://localhost:5000/&amp;#34;, &amp;#34;eslintConfig&amp;#34;: { &amp;#34;extends&amp;#34;: &amp;#34;react-app&amp;#34; }, &amp;#34;browserslist&amp;#34;: [ &amp;#34;&amp;gt;0.2%&amp;#34;, &amp;#34;not dead&amp;#34;, &amp;#34;not ie &amp;lt;= 11&amp;#34;, &amp;#34;not op_mini all&amp;#34; ] } These are all development-only options, in a sense:</description></item><item><title>Annotated MERN II: Backend</title><link>https://sverona.dev/blog/mern/backend/</link><pubDate>Sat, 02 Oct 2021 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/mern/backend/</guid><description>This post continues our look at James Vickery&amp;rsquo;s simple-mern repository. Today we&amp;rsquo;ll look at the backend, which is built in Express and Mongo and located under the client/ folder.
index.js This is the root Express server and router. Here are the libraries.
const express = require(&amp;#39;express&amp;#39;); const path = require(&amp;#39;path&amp;#39;); const bodyParser = require(&amp;#39;body-parser&amp;#39;); First we load the Express server and any routes we may need. There&amp;rsquo;s just the one.</description></item><item><title>Annotated MERN I: Node.js</title><link>https://sverona.dev/blog/mern/node/</link><pubDate>Fri, 01 Oct 2021 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/mern/node/</guid><description>This post begins our look at James Vickery&amp;rsquo;s simple-mern repository.
./README.md, ./LICENSE These are pretty self-explanatory, so I&amp;rsquo;ll ignore them.
./package.json This is similar to the package.json generated automatically by create-react-app. I&amp;rsquo;ll split it up into three sections. The first section contains metadata for npm.
{ &amp;#34;name&amp;#34;: &amp;#34;simple-mern&amp;#34;, &amp;#34;version&amp;#34;: &amp;#34;0.2.0&amp;#34;, &amp;#34;description&amp;#34;: &amp;#34;the simplest MERN (MongoDB, Express, React and Node) setup&amp;#34;, &amp;#34;main&amp;#34;: &amp;#34;index.js&amp;#34;, &amp;#34;author&amp;#34;: &amp;#34;James Vickery&amp;#34;, &amp;#34;license&amp;#34;: &amp;#34;MIT&amp;#34;, } The next section specifies custom shell commands to run with npm.</description></item><item><title>The sine and cosine curves</title><link>https://sverona.dev/trig/graphs/</link><pubDate>Wed, 15 Sep 2021 00:00:00 +0000</pubDate><guid>https://sverona.dev/trig/graphs/</guid><description>Let&amp;rsquo;s graph sine and cosine using the special values we know. (See diagram on board.)
One special note: we always graph these functions in radians. Whenever we graph trig functions, we think of radian measure.
\[ \begin{array}{r|ll} \theta &amp;amp; \mathbf \sin \theta &amp;amp; \mathbf \cos \theta \newline \hline 0^\circ = 0 \text{ rad} &amp;amp; 0 &amp;amp; 1 \newline 30^\circ = \pi/6 \text{ rad} &amp;amp; 1/2 &amp;amp; \sqrt3/2 \newline 45^\circ = \pi/4 \text{ rad} &amp;amp; \sqrt2/2 &amp;amp; \sqrt2/2 \newline 60^\circ = \pi/3 \text{ rad} &amp;amp; \sqrt3/2 &amp;amp; 1/2 \newline 90^\circ = \pi/2 \text{ rad} &amp;amp; 1 &amp;amp; 0 \newline \hline 120^\circ = 2\pi/3 \text{ rad} &amp;amp; \sqrt3/2 &amp;amp; -1/2 \newline 135^\circ = 3\pi/4 \text{ rad} &amp;amp; \sqrt2/2 &amp;amp; -\sqrt2/2 \newline 150^\circ = 5\pi/6 \text{ rad} &amp;amp; 1/2 &amp;amp; -\sqrt3/2 \newline 180^\circ = \pi \text{ rad} &amp;amp; 0 &amp;amp; -1 \newline \hline 210^\circ = 7\pi/6 \text{ rad} &amp;amp; \dots &amp;amp; \dots \end{array} \]</description></item><item><title>The unit circle</title><link>https://sverona.dev/trig/unit-circle/</link><pubDate>Wed, 08 Sep 2021 00:00:00 +0000</pubDate><guid>https://sverona.dev/trig/unit-circle/</guid><description>Here&amp;rsquo;s a link to section 7.3, which these notes cover.
Problem Set 2 From the Review Exercises for chapter 7, do 18-48 even, except for 34.
The unit circle It&amp;rsquo;s time to connect the circle with the angles on it with what we learned in the previous section.
Consider a circle of radius 1. Using two radii, form an angle in standard position (see diagram in class.) What happens as the angle increases from zero to \(90^\circ\) or \(\pi/2\) radians?</description></item><item><title>Right triangle trigonometry</title><link>https://sverona.dev/trig/right-triangle-trig/</link><pubDate>Wed, 01 Sep 2021 00:00:00 +0000</pubDate><guid>https://sverona.dev/trig/right-triangle-trig/</guid><description>Here&amp;rsquo;s textbook section 7.2, which these notes cover.
article div { } In this section, we&amp;rsquo;ll focus on obtaining angles from distances in right triangles.
The first and most important thing we&amp;rsquo;ll need is the Pythagorean theorem.
Let \(A \leq B &amp;lt; C\) be the sides of a right triangle. Then we have \[A^2 + B^2 = C^2.\] (See diagram in class.)
The longest side of a right triangle is called the hypotenuse.</description></item><item><title>Angles</title><link>https://sverona.dev/trig/angles/</link><pubDate>Fri, 27 Aug 2021 00:00:00 +0000</pubDate><guid>https://sverona.dev/trig/angles/</guid><description>Here&amp;rsquo;s textbook section 7.1, which these notes cover.
Some basic terms Some of these definitions are here for completeness more than anything else; don&amp;rsquo;t let their number bother you too much.
Basic definitions concerning angles:
A ray is a line emanating from a point. An angle is formed by two rays that share an endpoint. One ray is chosen to be the initial side of the angle, and the other becomes the terminal side.</description></item><item><title>Course Introduction</title><link>https://sverona.dev/trig/introduction/</link><pubDate>Wed, 25 Aug 2021 00:00:00 +0000</pubDate><guid>https://sverona.dev/trig/introduction/</guid><description>Trigonometry is all about triangles. More precisely, it&amp;rsquo;s the mathematics of angles and distances. We&amp;rsquo;ll talk about how to find angles based on distances and distances based on angles.
Okay, but why should I care about it?
Electricity. Geolocation. Astronomical parallax. Camera models. Audio codecs.</description></item><item><title>MATH 117: Trigonometry syllabus</title><link>https://sverona.dev/trig/syllabus/</link><pubDate>Sat, 21 Aug 2021 00:00:00 +0000</pubDate><guid>https://sverona.dev/trig/syllabus/</guid><description>Course info 117-006: CRN 36139, MWF 12:40pm - 1:35pm, SH 1101 117-007: CRN 36724, MWF 1:50pm - 2:45pm, COHH 1102
Instructor info Instructor: Sasha V. Malone (they/them/theirs)
Email: sasham (at) fastmail (dot) com
Office: COHH 4116 Office hours: MWF 3-4pm; in person, by email, or over Zoom. Other times by appointment or capture only.
Course description Trigonometry is used to determine lengths and distances based upon angles, or vice versa. Students in Math 117 will be able to apply knowledge of the following topics:</description></item><item><title>Mimicking LaTeX theorem environments with CSS</title><link>https://sverona.dev/blog/mimicking-latex-theorem-environments-with-css/</link><pubDate>Sun, 08 Aug 2021 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/mimicking-latex-theorem-environments-with-css/</guid><description>LaTeX supports &amp;ldquo;theorem environments,&amp;rdquo; like this:
(Image)
These aren&amp;rsquo;t hard to mimic with :before and :after:
article { counter-reset: definition theorem lemma example proposition corollary; } .definition:before { counter-increment: definition; content: &amp;#34;Definition &amp;#34; counter(definition) &amp;#34;.&amp;#34;; font-weight: bold; } .theorem:before { counter-increment: theorem; content: &amp;#34;Theorem &amp;#34; counter(theorem) &amp;#34;.&amp;#34;; font-weight: bold; } .lemma:before { counter-increment: lemma; content: &amp;#34;Lemma &amp;#34; counter(lemma) &amp;#34;.&amp;#34;; font-weight: bold; } .example:before { counter-increment: example; content: &amp;#34;Example &amp;#34; counter(example) &amp;#34;.</description></item><item><title>\(\pi\) and \(e\) and the GCD</title><link>https://sverona.dev/blog/gcd-ln/</link><pubDate>Sun, 24 Jan 2021 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/gcd-ln/</guid><description>While doing some research for my Project Euler post, I found myself drawn to something else that blew my mind in high school &amp;mdash; the connection between the greatest common divisor and the Riemann zeta function.
For those of you just joining us:
The greatest common divisor of two nonzero integers is the largest positive number that divides them both. The Riemann zeta function is the series \[\zeta(s) = \sum_{n = 1}^\infty \frac1{n^s} = \frac1{1^s} + \frac1{2^s} + \frac1{3^s} + \cdots.</description></item><item><title>Project Euler 1-100 in 49 hours</title><link>https://sverona.dev/blog/project-euler/</link><pubDate>Wed, 20 Jan 2021 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/project-euler/</guid><description>Project Euler is how I taught myself Python in high school, and so I find it incredibly nostalgic. It took 13-year-old me a lot of Googling and a few months to get through the first 100 problems.
10-odd years and a graduate degree later, I decided to come back and solve them as fast as I could. I&amp;rsquo;m no competitive programmer, but 24 hours seemed reasonable. Fortunately, I lack the stamina to code for that long, so I did it over a few days instead.</description></item><item><title>Inverse trigonometric functions</title><link>https://sverona.dev/trig/inverse-functions/</link><pubDate>Sun, 11 Oct 2020 00:00:00 +0000</pubDate><guid>https://sverona.dev/trig/inverse-functions/</guid><description>We&amp;rsquo;ve been studying trigonometric functions that take an angle (usually measured in radians) and that output a number (a coordinate, a slope, &amp;hellip;) Now we&amp;rsquo;re going to look at those functions' inverses.
Inverses review Remember, an inverse function undoes the function it&amp;rsquo;s an inverse of. So if I have \(f(x) = y,\) the inverse function has \(g(y) = x.\) The original function turns \(x\) into \(y\); its inverse turns \(y\) back into \(x.</description></item><item><title>Neural networks in time scale calculus</title><link>https://sverona.dev/blog/nabla/</link><pubDate>Tue, 07 May 2019 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/nabla/</guid><description>Neural networks are a popular technique for machine learning problems such as automated handwriting recognition, automated speech recognition, and time-series forecasting. On these tasks, so-called deep neural networks [Schmidhuber 2015] and convolutional neural networks [Ciresan et al. 2011] have performed at least as well as the best known non-neural-network statistical learning techniques. A typical neural network numerically solves an extremization problem using gradient descent in a high-dimensional Euclidean space using an algorithm known as backpropagation.</description></item><item><title>The dual simplex method, an introduction</title><link>https://sverona.dev/blog/dual-simplex/</link><pubDate>Mon, 01 Apr 2019 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/dual-simplex/</guid><description>The primal simplex method provides an algorithmic means for solving linear programs (hereinafter LPs.) This document motivates, defines, and applies the so-called dual simplex method, a slight variant which is useful for performing post hoc sensitivity analysis on LPs solved by the simplex method.
The primal simplex method In this section, we review the three steps of the usual primal method, following [Hillier-Lieberman], Frederick S. Hillier and Gerald J. Lieberman, Introduction to operations research, 10th ed.</description></item><item><title>Complex Variables</title><link>https://sverona.dev/blog/feynman/complex-variables/</link><pubDate>Mon, 28 Oct 1946 00:00:00 +0000</pubDate><guid>https://sverona.dev/blog/feynman/complex-variables/</guid><description>General Review Let \(A = a + bi\) and \(B = c + di.\) Then the rule of addition states \[A + B = (a + c) + i(b + d),\] and the rule of multiplication states \[AB = (ac - bd) + i(ad + bc).\]
An Argand diagram showing the complex number \(a + ib\) as a vector.
A complex number may also be represented as follows.</description></item></channel></rss>